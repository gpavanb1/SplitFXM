<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../img/favicon.ico" />
    <title>Adaptive Mesh Refinement - splitfxm</title>
    <link rel="stylesheet" href="../css/theme.css" />
    <link rel="stylesheet" href="../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
        <link href="../assets/_mkdocstrings.css" rel="stylesheet" />
        <link href="../assets/docs.css" rel="stylesheet" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "Adaptive Mesh Refinement";
        var mkdocs_page_input_path = "refine.md";
        var mkdocs_page_url = null;
      </script>
    
    <!--[if lt IE 9]>
      <script src="../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href=".." class="icon icon-home"> splitfxm
        </a>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="..">Home</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../start/">Getting Started</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../benchmark/">Benchmark</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../pricing/">Pricing</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">Code Documentation</span></p>
              <ul class="current">
                  <li class="toctree-l1"><a class="reference internal" href="../api/">Overview</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../model/">Model</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../domain/">Domain</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../ic/">Initial Conditions</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../bc/">Boundary Conditions</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../flux/">Finite-Volume Schemes</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" >Finite-Difference Schemes</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" href="../derivatives/">Overview</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../generate/">Scheme Generation</a>
                </li>
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../visualize/">Visualization</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" >Tutorials</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" href="../tutorials/advection_diffusion/">Advection-Diffusion</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../tutorials/sod_shock/">Sod Shock Tube</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../tutorials/conservative_sod_shock/">Conservative Sod Shock Tube</a>
                </li>
    </ul>
                  </li>
                  <li class="toctree-l1 current"><a class="reference internal current" href="#">Adaptive Mesh Refinement</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#splitfxm.refine">refine</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#splitfxm.refine.Refiner">Refiner</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#splitfxm.refine.Refiner.set_criteria">set_criteria</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#splitfxm.refine.Refiner.set_max_points">set_max_points</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#splitfxm.refine.Refiner.refine">refine</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#splitfxm.refine.Refiner.perform_changes">perform_changes</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#splitfxm.refine.Refiner.show_changes">show_changes</a>
    </li>
        </ul>
    </li>
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" >Internals</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" href="../internals/">Overview</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../cell/">Cell</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../boundary/">Boundary</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../system/">System</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../simulation/">Simulation</a>
                </li>
    </ul>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="..">splitfxm</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href=".." class="icon icon-home" aria-label="Docs"></a></li>
          <li class="breadcrumb-item">Code Documentation</li>
      <li class="breadcrumb-item active">Adaptive Mesh Refinement</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="adaptive-mesh-refinement">Adaptive Mesh Refinement</h1>
<p>One of the most important features of a robust solver is the ability to adaptively refine the mesh to capture the finer features of the solution. This is achieved by splitting the domain into smaller cells wherever more details are to be captured</p>


<div class="doc doc-object doc-module">



<a id="splitfxm.refine"></a>
    <div class="doc doc-contents first">



  <div class="doc doc-children">








<div class="doc doc-object doc-class">



<h2 id="splitfxm.refine.Refiner" class="doc doc-heading">
            <code>Refiner</code>


</h2>


    <div class="doc doc-contents ">


        <p>Class for refining grids using slope, curve, and prune.</p>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Raises:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
                  <code><span title="splitfxm.error.SFXM">SFXM</span></code>
              –
              <div class="doc-md-description">
                <p>If the <code>ratio</code> is less than 2.0, if <code>slope</code> or <code>curve</code> is not between 0.0 and 1.0, or if <code>prune</code> is not less than <code>curve</code> and <code>slope</code>.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
              <details class="quote">
                <summary>Source code in <code>splitfxm/refine.py</code></summary>
                <pre class="highlight"><code class="language-python">class Refiner:
    """
    Class for refining grids using slope, curve, and prune.

    Raises
    ------
    SFXM
        If the `ratio` is less than 2.0, if `slope` or `curve` is not between 0.0 and 1.0, or if `prune` is not less than `curve` and `slope`.
    """

    def __init__(self):
        # Default values
        # Borrowed from Cantera
        self._ratio = 10.0
        self._slope = 0.8
        self._curve = 0.8
        # Negative prune factor disables it
        self._prune = -0.001

        # Maximum points in grid
        self._npmax = 1000

        # Minimum range span factor
        self._min_range = 0.01

        # Minimum grid spacing
        self._min_grid = 1e-10

    def set_criteria(self, ratio, slope, curve, prune):
        """
        Sets the refinement criteria.

        Parameters
        ----------
        ratio : float
            The desired refinement ratio.
        slope : float
            The slope tolerance.
        curve : float
            The curve tolerance.
        prune : float
            The prune tolerance.

        Raises
        ------
        SFXM
            If the `ratio` is less than 2.0, if `slope` or `curve` is not between 0.0 and 1.0, or if `prune` is not less than `curve` and `slope`.
        """

        if ratio &lt; 2.0:
            raise SFXM(
                f"ratio must be greater than 2.0 ({ratio} was specified).")
        elif slope &lt; 0.0 or slope &gt; 1.0:
            raise SFXM(
                f"slope must be between 0.0 and 1.0 ({slope} was specified).")
        elif curve &lt; 0.0 or curve &gt; 1.0:
            raise SFXM(
                f"curve must be between 0.0 and 1.0 ({curve} was specified).")
        elif prune &gt; curve or prune &gt; slope:
            raise SFXM(
                f"prune must be less than 'curve' and 'slope' ({prune} was specified)."
            )

        self._ratio = ratio
        self._slope = slope
        self._curve = curve
        self._prune = prune

    def set_max_points(self, npmax):
        """
        Sets the maximum number of points in the grid.

        Parameters
        ----------
        npmax : int
            Maximum number of points in the grid.

        """
        self._npmax = npmax

    def refine(self, d: Domain):
        """
        Refines the grid using given criteria.

        Parameters
        ----------
        d : Domain
            Domain object to be refined.

        Raises
        ------
        SFXM
            If maximum number of points in the grid is exceeded.
        """

        # https://cantera.org/documentation/docs-2.5/doxygen/html/dd/d3c/refine_8cpp_source.html
        # Using only slope, curve and prune
        cells = d.interior()
        n = len(cells)

        # Keep map
        # 1 means cell stays and -1 means it goes
        # Loc map
        # 1 means add a point there
        # c map
        # Addition due to that variable
        keep = {}
        c = {}
        loc = {}

        # Preserve border points
        keep[0] = 1
        keep[n - 1] = 1

        if len(cells) &gt; self._npmax:
            raise SFXM("Exceeded maximum number of points")

        z = [cells[i].x() for i in range(n)]
        dz = [cells[i + 1].x() - cells[i].x() for i in range(n - 1)]
        # nv -&gt; Number of variables
        nv = len(cells[1].values())

        for i in range(nv):
            name = d.component_name(i)

            # Get components at all points
            v = [cells[j].value(i) for j in range(n)]

            # Slopes (s) for component i
            s = [
                (cells[j + 1].value(i) - cells[j].value(i)) / (z[j + 1] - z[j])
                for j in range(n - 1)
            ]

            # Range of values
            vmin = min(v)
            vmax = max(v)
            # Range of slopes
            smin = min(s)
            smax = max(s)

            # Max absolute values of values and slopes
            aa = max(abs(vmin), abs(vmax))
            ss = max(abs(smin), abs(smax))

            # refine based on component i only if the range of v is
            # greater than a fraction 'min_range' of max |v|. This
            # eliminates components that consist of small fluctuations
            # on a constant background.
            if (vmax - vmin) &gt; self._min_range * aa:
                # maximum allowable difference in value between adjacent
                # points.
                dmax = self._slope * (vmax - vmin) + eps
                for j in range(n - 1):
                    r = abs(v[j + 1] - v[j]) / dmax
                    if r &gt; 1.0 and dz[j] &gt;= 2 * self._min_grid:
                        loc[j] = 1
                        c[name] = 1

                    if r &gt;= self._prune:
                        keep[j] = 1
                        keep[j + 1] = 1
                    elif j not in keep:
                        keep[j] = -1

            # refine based on the slope of component i only if the
            # range of s is greater than a fraction 'min_range' of max
            # |s|. This eliminates components that consist of small
            # fluctuations on a constant slope background.
            if (smax - smin) &gt; self._min_range * ss:
                # maximum allowable difference in slope between
                # adjacent points
                dmax = self._curve * (smax - smin)
                for j in range(n - 2):
                    r = abs(s[j + 1] - s[j]) / (dmax + (eps / dz[j]))
                    if (
                        r &gt; 1.0
                        and dz[j] &gt;= 2 * self._min_grid
                        and dz[j + 1] &gt;= 2 * self._min_grid
                    ):
                        c[name] = 1
                        loc[j] = 1
                        loc[j + 1] = 1

                    if r &gt;= self._prune:
                        keep[j + 1] = 1
                    elif (j + 1) not in keep:
                        keep[j + 1] = -1

        # Refine based on properties of the grid itself
        for j in range(1, n - 1):
            # Add a new point if the ratio with left interval is too large
            if dz[j] &gt; self._ratio * dz[j - 1]:
                loc[j] = 1
                c[f"point {j}"] = 1
                keep[j - 1] = 1
                keep[j] = 1
                keep[j + 1] = 1
                keep[j + 2] = 1

            # Add a point if the ratio with right interval is too large
            if dz[j] &lt; dz[j - 1] / self._ratio:
                loc[j - 1] = 1
                c[f"point {max(j-1, 0)}"] = 1
                keep[j - 2] = 1
                keep[j - 1] = 1
                keep[j] = 1
                keep[j + 1] = 1

            # Keep the point if removing would make the ratio with the left
            # interval too large.
            if j &gt; 1 and z[j + 1] - z[j - 1] &gt; self._ratio * dz[j - 2]:
                keep[j] = 1

            # Keep the point if removing would make the ratio with the right
            # interval too large.
            if j &lt; n - 2 and z[j + 1] - z[j - 1] &gt; self._ratio * dz[j + 1]:
                keep[j] = 1

        # Don't allow pruning to remove multiple adjacent grid points
        # in a single pass.
        for j in range(2, n - 1):
            if j in keep and j - 1 in keep and keep[j] == -1 and keep[j - 1] == -1:
                keep[j] = 1

        # Finalize AMR changes
        self.show_changes(loc, c, keep)
        self.perform_changes(d, loc, keep)

    def perform_changes(self, d, loc, keep):
        """
        Perform changes to the domain d according to the changes specified in
        loc and keep.

        Parameters
        ----------
        d : Domain
            The domain to perform changes on.
        loc : Dict[int, int]
            A dictionary with locations where insertions are to happen
        keep : Dict[int, int]
            A dictionary that indicates whether a cell is to be kept or deleted. -1 indicates deletion and 1 indicates preservation
        """
        #######
        # AMR
        # Need to mark for deletion before deleting
        # as cell addition indices need to make sense
        #######
        cells = d.interior()
        # Iterate over keep and remove points
        for i, cell in enumerate(cells):
            if i in keep and keep[i] == -1:
                cell.to_delete = True

        # Add cells at loc
        # Create separate list of cells and merge
        to_merge = []
        for i in loc.keys():
            x = 0.5 * (cells[i + 1].x() + cells[i].x())
            value = 0.5 * (cells[i + 1].values() + cells[i].values())
            to_merge.append(Cell(x, value))

        # Delete marked cells
        for i, cell in enumerate(cells):
            if cell.to_delete:
                del cells[i]

        # Merge cells and sort by x
        cells += to_merge
        cells.sort()

        # Set interior to cells
        d.set_interior(cells)

    def show_changes(self, loc, c, keep):
        """
        Print information about changes made to the domain.
        """
        print("#" * 78)
        # Show additions
        if len(loc) != 0:
            print("Refining grid...")
            print("New points inserted after grid points ")
            for i in loc.keys():
                print(i, end=" ")
            print("    to resolve ", end="")
            for name in c.keys():
                print(name, end=" ")
            print("")
        else:
            print("No new points needed")

        # Show deletions
        num_deleted = list(keep.values()).count(-1)
        if num_deleted != 0:
            print("Deleted points at ")
            for i in keep.keys():
                if keep[i] == -1:
                    print(i, end=" ")
            print("")
        else:
            print("No new points deleted")
        print("#" * 78)</code></pre>
              </details>



  <div class="doc doc-children">









<div class="doc doc-object doc-function">


<h3 id="splitfxm.refine.Refiner.set_criteria" class="doc doc-heading">
            <code class="highlight language-python">set_criteria(ratio, slope, curve, prune)</code>

</h3>


    <div class="doc doc-contents ">

        <p>Sets the refinement criteria.</p>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>ratio</code></b>
                  (<code>float</code>)
              –
              <div class="doc-md-description">
                <p>The desired refinement ratio.</p>
              </div>
            </li>
            <li>
              <b><code>slope</code></b>
                  (<code>float</code>)
              –
              <div class="doc-md-description">
                <p>The slope tolerance.</p>
              </div>
            </li>
            <li>
              <b><code>curve</code></b>
                  (<code>float</code>)
              –
              <div class="doc-md-description">
                <p>The curve tolerance.</p>
              </div>
            </li>
            <li>
              <b><code>prune</code></b>
                  (<code>float</code>)
              –
              <div class="doc-md-description">
                <p>The prune tolerance.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Raises:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
                  <code><span title="splitfxm.error.SFXM">SFXM</span></code>
              –
              <div class="doc-md-description">
                <p>If the <code>ratio</code> is less than 2.0, if <code>slope</code> or <code>curve</code> is not between 0.0 and 1.0, or if <code>prune</code> is not less than <code>curve</code> and <code>slope</code>.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
            <details class="quote">
              <summary>Source code in <code>splitfxm/refine.py</code></summary>
              <pre class="highlight"><code class="language-python">def set_criteria(self, ratio, slope, curve, prune):
    """
    Sets the refinement criteria.

    Parameters
    ----------
    ratio : float
        The desired refinement ratio.
    slope : float
        The slope tolerance.
    curve : float
        The curve tolerance.
    prune : float
        The prune tolerance.

    Raises
    ------
    SFXM
        If the `ratio` is less than 2.0, if `slope` or `curve` is not between 0.0 and 1.0, or if `prune` is not less than `curve` and `slope`.
    """

    if ratio &lt; 2.0:
        raise SFXM(
            f"ratio must be greater than 2.0 ({ratio} was specified).")
    elif slope &lt; 0.0 or slope &gt; 1.0:
        raise SFXM(
            f"slope must be between 0.0 and 1.0 ({slope} was specified).")
    elif curve &lt; 0.0 or curve &gt; 1.0:
        raise SFXM(
            f"curve must be between 0.0 and 1.0 ({curve} was specified).")
    elif prune &gt; curve or prune &gt; slope:
        raise SFXM(
            f"prune must be less than 'curve' and 'slope' ({prune} was specified)."
        )

    self._ratio = ratio
    self._slope = slope
    self._curve = curve
    self._prune = prune</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="splitfxm.refine.Refiner.set_max_points" class="doc doc-heading">
            <code class="highlight language-python">set_max_points(npmax)</code>

</h3>


    <div class="doc doc-contents ">

        <p>Sets the maximum number of points in the grid.</p>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>npmax</code></b>
                  (<code>int</code>)
              –
              <div class="doc-md-description">
                <p>Maximum number of points in the grid.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
            <details class="quote">
              <summary>Source code in <code>splitfxm/refine.py</code></summary>
              <pre class="highlight"><code class="language-python">def set_max_points(self, npmax):
    """
    Sets the maximum number of points in the grid.

    Parameters
    ----------
    npmax : int
        Maximum number of points in the grid.

    """
    self._npmax = npmax</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="splitfxm.refine.Refiner.refine" class="doc doc-heading">
            <code class="highlight language-python">refine(d)</code>

</h3>


    <div class="doc doc-contents ">

        <p>Refines the grid using given criteria.</p>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>d</code></b>
                  (<code><a class="autorefs autorefs-internal" title="splitfxm.domain.Domain" href="../domain/#splitfxm.domain.Domain">Domain</a></code>)
              –
              <div class="doc-md-description">
                <p>Domain object to be refined.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Raises:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
                  <code><span title="splitfxm.error.SFXM">SFXM</span></code>
              –
              <div class="doc-md-description">
                <p>If maximum number of points in the grid is exceeded.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
            <details class="quote">
              <summary>Source code in <code>splitfxm/refine.py</code></summary>
              <pre class="highlight"><code class="language-python">def refine(self, d: Domain):
    """
    Refines the grid using given criteria.

    Parameters
    ----------
    d : Domain
        Domain object to be refined.

    Raises
    ------
    SFXM
        If maximum number of points in the grid is exceeded.
    """

    # https://cantera.org/documentation/docs-2.5/doxygen/html/dd/d3c/refine_8cpp_source.html
    # Using only slope, curve and prune
    cells = d.interior()
    n = len(cells)

    # Keep map
    # 1 means cell stays and -1 means it goes
    # Loc map
    # 1 means add a point there
    # c map
    # Addition due to that variable
    keep = {}
    c = {}
    loc = {}

    # Preserve border points
    keep[0] = 1
    keep[n - 1] = 1

    if len(cells) &gt; self._npmax:
        raise SFXM("Exceeded maximum number of points")

    z = [cells[i].x() for i in range(n)]
    dz = [cells[i + 1].x() - cells[i].x() for i in range(n - 1)]
    # nv -&gt; Number of variables
    nv = len(cells[1].values())

    for i in range(nv):
        name = d.component_name(i)

        # Get components at all points
        v = [cells[j].value(i) for j in range(n)]

        # Slopes (s) for component i
        s = [
            (cells[j + 1].value(i) - cells[j].value(i)) / (z[j + 1] - z[j])
            for j in range(n - 1)
        ]

        # Range of values
        vmin = min(v)
        vmax = max(v)
        # Range of slopes
        smin = min(s)
        smax = max(s)

        # Max absolute values of values and slopes
        aa = max(abs(vmin), abs(vmax))
        ss = max(abs(smin), abs(smax))

        # refine based on component i only if the range of v is
        # greater than a fraction 'min_range' of max |v|. This
        # eliminates components that consist of small fluctuations
        # on a constant background.
        if (vmax - vmin) &gt; self._min_range * aa:
            # maximum allowable difference in value between adjacent
            # points.
            dmax = self._slope * (vmax - vmin) + eps
            for j in range(n - 1):
                r = abs(v[j + 1] - v[j]) / dmax
                if r &gt; 1.0 and dz[j] &gt;= 2 * self._min_grid:
                    loc[j] = 1
                    c[name] = 1

                if r &gt;= self._prune:
                    keep[j] = 1
                    keep[j + 1] = 1
                elif j not in keep:
                    keep[j] = -1

        # refine based on the slope of component i only if the
        # range of s is greater than a fraction 'min_range' of max
        # |s|. This eliminates components that consist of small
        # fluctuations on a constant slope background.
        if (smax - smin) &gt; self._min_range * ss:
            # maximum allowable difference in slope between
            # adjacent points
            dmax = self._curve * (smax - smin)
            for j in range(n - 2):
                r = abs(s[j + 1] - s[j]) / (dmax + (eps / dz[j]))
                if (
                    r &gt; 1.0
                    and dz[j] &gt;= 2 * self._min_grid
                    and dz[j + 1] &gt;= 2 * self._min_grid
                ):
                    c[name] = 1
                    loc[j] = 1
                    loc[j + 1] = 1

                if r &gt;= self._prune:
                    keep[j + 1] = 1
                elif (j + 1) not in keep:
                    keep[j + 1] = -1

    # Refine based on properties of the grid itself
    for j in range(1, n - 1):
        # Add a new point if the ratio with left interval is too large
        if dz[j] &gt; self._ratio * dz[j - 1]:
            loc[j] = 1
            c[f"point {j}"] = 1
            keep[j - 1] = 1
            keep[j] = 1
            keep[j + 1] = 1
            keep[j + 2] = 1

        # Add a point if the ratio with right interval is too large
        if dz[j] &lt; dz[j - 1] / self._ratio:
            loc[j - 1] = 1
            c[f"point {max(j-1, 0)}"] = 1
            keep[j - 2] = 1
            keep[j - 1] = 1
            keep[j] = 1
            keep[j + 1] = 1

        # Keep the point if removing would make the ratio with the left
        # interval too large.
        if j &gt; 1 and z[j + 1] - z[j - 1] &gt; self._ratio * dz[j - 2]:
            keep[j] = 1

        # Keep the point if removing would make the ratio with the right
        # interval too large.
        if j &lt; n - 2 and z[j + 1] - z[j - 1] &gt; self._ratio * dz[j + 1]:
            keep[j] = 1

    # Don't allow pruning to remove multiple adjacent grid points
    # in a single pass.
    for j in range(2, n - 1):
        if j in keep and j - 1 in keep and keep[j] == -1 and keep[j - 1] == -1:
            keep[j] = 1

    # Finalize AMR changes
    self.show_changes(loc, c, keep)
    self.perform_changes(d, loc, keep)</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="splitfxm.refine.Refiner.perform_changes" class="doc doc-heading">
            <code class="highlight language-python">perform_changes(d, loc, keep)</code>

</h3>


    <div class="doc doc-contents ">

        <p>Perform changes to the domain d according to the changes specified in
loc and keep.</p>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>d</code></b>
                  (<code><a class="autorefs autorefs-internal" title="splitfxm.domain.Domain" href="../domain/#splitfxm.domain.Domain">Domain</a></code>)
              –
              <div class="doc-md-description">
                <p>The domain to perform changes on.</p>
              </div>
            </li>
            <li>
              <b><code>loc</code></b>
                  (<code>Dict[int, int]</code>)
              –
              <div class="doc-md-description">
                <p>A dictionary with locations where insertions are to happen</p>
              </div>
            </li>
            <li>
              <b><code>keep</code></b>
                  (<code>Dict[int, int]</code>)
              –
              <div class="doc-md-description">
                <p>A dictionary that indicates whether a cell is to be kept or deleted. -1 indicates deletion and 1 indicates preservation</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
            <details class="quote">
              <summary>Source code in <code>splitfxm/refine.py</code></summary>
              <pre class="highlight"><code class="language-python">def perform_changes(self, d, loc, keep):
    """
    Perform changes to the domain d according to the changes specified in
    loc and keep.

    Parameters
    ----------
    d : Domain
        The domain to perform changes on.
    loc : Dict[int, int]
        A dictionary with locations where insertions are to happen
    keep : Dict[int, int]
        A dictionary that indicates whether a cell is to be kept or deleted. -1 indicates deletion and 1 indicates preservation
    """
    #######
    # AMR
    # Need to mark for deletion before deleting
    # as cell addition indices need to make sense
    #######
    cells = d.interior()
    # Iterate over keep and remove points
    for i, cell in enumerate(cells):
        if i in keep and keep[i] == -1:
            cell.to_delete = True

    # Add cells at loc
    # Create separate list of cells and merge
    to_merge = []
    for i in loc.keys():
        x = 0.5 * (cells[i + 1].x() + cells[i].x())
        value = 0.5 * (cells[i + 1].values() + cells[i].values())
        to_merge.append(Cell(x, value))

    # Delete marked cells
    for i, cell in enumerate(cells):
        if cell.to_delete:
            del cells[i]

    # Merge cells and sort by x
    cells += to_merge
    cells.sort()

    # Set interior to cells
    d.set_interior(cells)</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="splitfxm.refine.Refiner.show_changes" class="doc doc-heading">
            <code class="highlight language-python">show_changes(loc, c, keep)</code>

</h3>


    <div class="doc doc-contents ">

        <p>Print information about changes made to the domain.</p>

            <details class="quote">
              <summary>Source code in <code>splitfxm/refine.py</code></summary>
              <pre class="highlight"><code class="language-python">def show_changes(self, loc, c, keep):
    """
    Print information about changes made to the domain.
    """
    print("#" * 78)
    # Show additions
    if len(loc) != 0:
        print("Refining grid...")
        print("New points inserted after grid points ")
        for i in loc.keys():
            print(i, end=" ")
        print("    to resolve ", end="")
        for name in c.keys():
            print(name, end=" ")
        print("")
    else:
        print("No new points needed")

    # Show deletions
    num_deleted = list(keep.values()).count(-1)
    if num_deleted != 0:
        print("Deleted points at ")
        for i in keep.keys():
            if keep[i] == -1:
                print(i, end=" ")
        print("")
    else:
        print("No new points deleted")
    print("#" * 78)</code></pre>
            </details>
    </div>

</div>



  </div>

    </div>

</div>




  </div>

    </div>

</div>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../tutorials/conservative_sod_shock/" class="btn btn-neutral float-left" title="Conservative Sod Shock Tube"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../internals/" class="btn btn-neutral float-right" title="Overview">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href="../tutorials/conservative_sod_shock/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../internals/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script src="../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "..";</script>
    <script src="../js/theme_extra.js"></script>
    <script src="../js/theme.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
