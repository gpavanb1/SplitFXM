<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../img/favicon.ico" />
    <title>Simulation - splitfxm</title>
    <link rel="stylesheet" href="../css/theme.css" />
    <link rel="stylesheet" href="../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
        <link href="../assets/_mkdocstrings.css" rel="stylesheet" />
        <link href="../assets/docs.css" rel="stylesheet" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "Simulation";
        var mkdocs_page_input_path = "simulation.md";
        var mkdocs_page_url = null;
      </script>
    
    <!--[if lt IE 9]>
      <script src="../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href=".." class="icon icon-home"> splitfxm
        </a>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="..">Home</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../start/">Getting Started</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../benchmark/">Benchmark</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../pricing/">Pricing</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">Code Documentation</span></p>
              <ul class="current">
                  <li class="toctree-l1"><a class="reference internal" href="../api/">Overview</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../model/">Model</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../domain/">Domain</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../ic/">Initial Conditions</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../bc/">Boundary Conditions</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../flux/">Finite-Volume Schemes</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" >Finite-Difference Schemes</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" href="../derivatives/">Overview</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../generate/">Scheme Generation</a>
                </li>
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../visualize/">Visualization</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../refine/">Adaptive Mesh Refinement</a>
                  </li>
                  <li class="toctree-l1 current"><a class="reference internal current" >Internals</a>
    <ul class="current">
                <li class="toctree-l2"><a class="reference internal" href="../internals/">Overview</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../cell/">Cell</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../boundary/">Boundary</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../system/">System</a>
                </li>
                <li class="toctree-l2 current"><a class="reference internal current" href="#">Simulation</a>
    <ul class="current">
    <li class="toctree-l3"><a class="reference internal" href="#splitfxm.simulation">simulation</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#splitfxm.simulation.Simulation">Simulation</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#splitfxm.simulation.Simulation.__init__">__init__</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#splitfxm.simulation.Simulation.get_shape_from_list">get_shape_from_list</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#splitfxm.simulation.Simulation.initialize_from_list">initialize_from_list</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#splitfxm.simulation.Simulation.get_residuals_from_list">get_residuals_from_list</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#splitfxm.simulation.Simulation.extend_bounds">extend_bounds</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#splitfxm.simulation.Simulation.jacobian">jacobian</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#splitfxm.simulation.Simulation.evolve">evolve</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#splitfxm.simulation.Simulation.steady_state">steady_state</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#splitfxm.simulation.array_list_reshape">array_list_reshape</a>
    </li>
    </ul>
                </li>
    </ul>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="..">splitfxm</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href=".." class="icon icon-home" aria-label="Docs"></a></li>
          <li class="breadcrumb-item">Code Documentation</li>
          <li class="breadcrumb-item">Internals</li>
      <li class="breadcrumb-item active">Simulation</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="simulation">Simulation</h1>
<p>This is the main object that is used to run the simulation. It contains the domain, model, initial conditions, boundary conditions, and the scheme.</p>


<div class="doc doc-object doc-module">



<a id="splitfxm.simulation"></a>
    <div class="doc doc-contents first">



  <div class="doc doc-children">








<div class="doc doc-object doc-class">



<h2 id="splitfxm.simulation.Simulation" class="doc doc-heading">
            <code>Simulation</code>


</h2>


    <div class="doc doc-contents ">


        <p>A class representing a simulation.</p>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>d</code></b>
                  (<code><a class="autorefs autorefs-internal" title="splitfxm.domain.Domain" href="../domain/#splitfxm.domain.Domain">Domain</a></code>)
              –
              <div class="doc-md-description">
                <p>The domain on which to perform the simulation.</p>
              </div>
            </li>
            <li>
              <b><code>m</code></b>
                  (<code><a class="autorefs autorefs-internal" title="splitfxm.model.Model" href="../model/#splitfxm.model.Model">Model</a></code>)
              –
              <div class="doc-md-description">
                <p>The model to use in the simulation.</p>
              </div>
            </li>
            <li>
              <b><code>ics</code></b>
                  (<code>dict</code>)
              –
              <div class="doc-md-description">
                <p>The initial conditions to apply to the domain.</p>
              </div>
            </li>
            <li>
              <b><code>bcs</code></b>
                  (<code>dict</code>)
              –
              <div class="doc-md-description">
                <p>The boundary conditions to apply to the domain.</p>
              </div>
            </li>
            <li>
              <b><code>scheme</code></b>
                  (<code>Schemes</code>)
              –
              <div class="doc-md-description">
                <p>The discretization scheme to use for the simulation.</p>
              </div>
            </li>
            <li>
              <b><code>scheme_opts</code></b>
                  (<code>dict</code>, default:
                      <code>{}</code>
)
              –
              <div class="doc-md-description">
                <p>A dictionary of options for the scheme.</p>
              </div>
            </li>
            <li>
              <b><code>ss</code></b>
                  (<code>dict</code>, default:
                      <code>{}</code>
)
              –
              <div class="doc-md-description">
                <p>The steady-state solver settings to use in the simulation.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
              <details class="quote">
                <summary>Source code in <code>splitfxm/simulation.py</code></summary>
                <pre class="highlight"><code class="language-python">class Simulation:
    """
    A class representing a simulation.

    Parameters
    ----------
    d : Domain
        The domain on which to perform the simulation.
    m : Model
        The model to use in the simulation.
    ics : dict
        The initial conditions to apply to the domain.
    bcs : dict
        The boundary conditions to apply to the domain.
    scheme : Schemes
        The discretization scheme to use for the simulation.
    scheme_opts : dict, optional
        A dictionary of options for the scheme.
    ss : dict, optional
        The steady-state solver settings to use in the simulation.
    """

    def __init__(self, d: Domain, m: Model, ics: dict, bcs: dict, scheme, scheme_opts: dict = {}, ss: dict = {}):
        """
        Initialize a Simulation object.
        """
        self._d = d
        self._s = System(m, scheme, scheme_opts)
        self._r = Refiner()
        self._bcs = bcs

        # Steady-state solver settings
        self._ss = ss

        # Set initial conditions
        for c, ictype in ics.items():
            set_initial_condition(self._d, c, ictype)

        # Fill BCs
        for c, bctype in self._bcs.items():
            apply_BC(self._d, c, bctype)

        # Check if stencil size matches
        boundary_cells = self._d.boundaries()[0] + self._d.boundaries()[1]
        if stencil_sizes.get(self._s._scheme) != len(boundary_cells) + 1:
            raise SFXM("Stencil size does not match boundary conditions")

    ############
    # List related methods
    ############

    def get_shape_from_list(self, l):
        """
        Get the shape of the list when reshaped into a NumPy array.

        Parameters
        ----------
        l : list
            The list to get the shape for.

        Returns
        -------
        num_points : int
            The number of points in the reshaped array.
        nv : int
            The number of components per point in the reshaped array.
        """

        nv = self._d.num_components()

        if len(l) % nv != 0:
            raise SFXM("List length not aligned with interior size")

        num_points = len(l) // nv

        return num_points, nv

    def initialize_from_list(self, l, split=False, split_loc=None):
        """
        Initialize the domain from a list of values.

        Parameters
        ----------
        l : list
            The list of values to initialize the domain with.
        split : bool, optional
            Whether to split the values into outer and inner blocks. Defaults to False.
        split_loc : int, optional
            The location to split the values at. Required if `split` is True.
        """

        # Just demarcate every nv entries as a row in the 2D array
        num_points, nv = self.get_shape_from_list(l)

        if split:

            if split_loc is None:
                raise SFXM("Split location must be specified in this case")

            if split_loc &gt; nv or split_loc &lt; 0:
                raise SFXM("Split location must be between 0 and nv-1")

            # Same as SplitNewton convention
            # Outer system will be excluding `loc`
            outer_block = array_list_reshape(
                l[: split_loc * num_points], (num_points, split_loc))
            inner_block = array_list_reshape(
                l[split_loc * num_points:], (num_points, nv - split_loc))

            # Concatenate outer and inner blocks
            block = np.hstack((outer_block, inner_block))
        else:
            # No need to split, just use the values_array directly
            block = array_list_reshape(l, (num_points, nv))

        # Assign values to cells in domain
        cells = self._d.interior()
        for i, b in enumerate(cells):
            b.set_values(block[i, :])

    def get_residuals_from_list(self, l, split=False, split_loc=None):
        """
        Get the residuals for the domain given a list of values.

        Parameters
        ----------
        l : list
            The list of values to get the residuals for.
        split : bool, optional
            Whether to split the residuals into outer and inner blocks. Defaults to False.
        split_loc : int, optional
            The location to split the residuals at. Required if `split` is True.

        Returns
        -------
        residual_list : list
            The list of residual values.
        """

        # Assign values from list
        # Note domain already exists and we preserve distances
        self.initialize_from_list(l, split, split_loc)

        # Fill BCs
        for c, bctype in self._bcs.items():
            apply_BC(self._d, c, bctype)

        interior_residual_block = self._s.residuals(self._d)

        if split:
            # Split the array into outer and inner blocks
            outer_block = interior_residual_block[:, :split_loc].flatten()
            inner_block = interior_residual_block[:, split_loc:].flatten()
            # Concatenate the flattened outer and inner blocks
            residual_list = np.concatenate((outer_block, inner_block))
        else:
            # Flatten the entire residual block
            residual_list = interior_residual_block.flatten()

        return residual_list

    def extend_bounds(self, bounds, num_points, nv, split=False, split_loc=None):
        """
        Extends the provided input bounds based on whether there is a split or not.

        Parameters
        ----------
        bounds : list of list
            A list containing two lists, each of size `nv`, representing the lower and upper bounds.
        num_points : int
            The number of points to extend each bound to.
        nv : int
            The number of variables, indicating the length of each bound list.
        split : bool, optional
            A flag indicating whether to split the bounds at a specific location. Default is `False`.
        split_loc : int, optional
            The index at which to split the bounds if `split` is `True`. Default is `None`.

        Returns
        -------
        list of list
            A list containing the extended lower and upper bounds.
        """
        # Check if bounds is a 2-list, each of size nv
        if bounds is None:
            return None

        if len(bounds) != 2:
            raise SFXM("Bounds must be a list of 2 lists")
        else:
            if len(bounds[0]) != nv or len(bounds[1]) != nv:
                raise SFXM(
                    "Each list in bounds must be of length - number of variables")

        if not split:
            return [bounds[0] * num_points, bounds[1] * num_points]
        else:
            if split_loc is None:
                raise SFXM("split_loc must be provided if split is True")
            return [bounds[0][:split_loc] * num_points + bounds[0][split_loc:] * num_points,
                    bounds[1][:split_loc] * num_points + bounds[1][split_loc:] * num_points]

    ############
    # Solution related methods
    ############

    def jacobian(self, l, split=False, split_loc=None, epsilon=1e-8):
        """
        Calculate the Jacobian of the system using finite differences.

        Parameters
        ----------
        l : list
            The list of values to calculate the Jacobian for.
        split : bool, optional
            Whether to split the Jacobian into outer and inner blocks. Defaults to False.
        split_loc : int, optional
            The location to split the Jacobian at. Required if `split` is True.
        epsilon : float, optional
            The finite difference step size. Defaults to 1e-8.

        Returns
        -------
        jac : scipy.sparse.lil_matrix
            The Jacobian of the system.
        """
        # Initialize domain from the provided list and apply boundary conditions
        self.initialize_from_list(l, split, split_loc)
        for c, bctype in self._bcs.items():
            apply_BC(self._d, c, bctype)

        # Find the variables with periodic BCs and their directions
        periodic_bcs_dict = get_periodic_bcs(self._bcs, self._d)

        # Get the number of points and variables
        num_points, nv = self.get_shape_from_list(l)
        n = num_points * nv

        # Create a sparse matrix for the Jacobian
        jac = lil_matrix((n, n))

        # Retrieve cells and boundary parameters
        cells = self._d.cells()
        nb_left, nb_right, ilo, ihi = self._d.nb(btype.LEFT), self._d.nb(
            btype.RIGHT), self._d.ilo(), self._d.ihi()

        # Use same point iteration as system residuals
        # Iterating over interior points
        for i in range(ilo, ihi + 1):
            # Define the neighborhood and band around the current cell
            cell_sub = [cells[i + offset]
                        for offset in range(-nb_left, nb_right + 1)]
            # Indices of points that affect the Jacobian (or part of the band)
            band = list(range(max(ilo, i - nb_left),
                        min(ihi + 1, i + nb_right + 1)))

            # Calculate unperturbed residuals
            rhs = self._s._model.equation().residuals(cell_sub, self._s._scheme)

            # Perturb each variable and compute the Jacobian columns
            for j in range(nv):
                # Extend the band if required for that variable
                # Only required for periodic BC for now
                if j in periodic_bcs_dict.keys():
                    dirs = periodic_bcs_dict[j]
                    band = extend_band(band, dirs, i, self._d)

                for loc in band:
                    # Compared to center_cell, what is the index of the cell
                    # to be perturbed
                    cell = cells[loc]
                    current_value = cell.value(j)

                    # Perturb the current variable and compute perturbed residuals
                    cell.set_value(j, current_value + epsilon)

                    # Apply BC again if cell is adjacent to boundary
                    if ilo in band or ihi in band:
                        for c, bctype in self._bcs.items():
                            apply_BC(self._d, c, bctype)

                    # Calculate updated residual
                    rhs_pert = self._s._model.equation().residuals(cell_sub, self._s._scheme)

                    # Reset the value
                    cell.set_value(j, current_value)
                    # Apply BC again if cell is adjacent to boundary
                    if ilo in band or ihi in band:
                        for c, bctype in self._bcs.items():
                            apply_BC(self._d, c, bctype)

                    # Compute the difference and assign to the Jacobian
                    col = (rhs_pert - rhs) / epsilon

                    # Assign the calculated column to the Jacobian
                    # Blocks of nv*nv matrices are computed
                    # row_idx gives the start of the column vector
                    # First point starts at 0, second point starts at nv and so on
                    # For col_idx, loc - ilo gives shift from 0 for the block in multiples of nv
                    if not split:
                        row_idx = (i - ilo) * nv
                        col_idx = (loc - ilo) * nv + j
                        jac[row_idx:row_idx + nv, col_idx] = col
                    else:
                        # Split location will be checked in initialize_from_list
                        # Sizes of the sub-Jacobians
                        na, nc = split_loc, (nv - split_loc)
                        # Jumps of block_offset instead of nv here
                        block_offset = num_points * na

                        # First part of residuals
                        # Same as previous but use na instead
                        row_idx = (i - ilo) * na
                        # col_idx jumps to right part of Jacobian
                        # depending on the variable if pre- or post-split
                        if j &lt; na:
                            col_idx = (loc - ilo) * na + j
                        else:
                            # Jumps of nc in post-split parts
                            # j-na to ensure post-split variables start afresh
                            col_idx = block_offset + \
                                (loc - ilo) * nc + (j - na)

                        jac[row_idx:row_idx + na, col_idx] = col[:na]

                        # Second part of residuals
                        # col_idx remains same as previous
                        row_idx = block_offset + (i - ilo) * nc
                        jac[row_idx:row_idx + nc, col_idx] = col[na:]

        return jac

    def evolve(self, t_diff: float, split=False, split_loc=None, method='RK45', rtol=1e-3, atol=1e-6, max_step=np.inf):
        """
        Evolve the system in time using an ODE solver for a given time step.

        Parameters
        ----------
        t_diff : float
            The time advancement to be made.
        split : bool, optional
            If True, applies a domain splitting technique. Defaults to False.
        split_loc : optional
            Specifies the location or configuration for domain splitting. Default is None.
        method : str, optional
            The integration method to use for solving the system. Defaults to 'RK45'.
            Possible options include 'RK45', 'RK23', 'DOP853', etc. 
            Refer to the scipy documentation for a full list of supported methods.
        rtol : float, optional
            The relative tolerance for the solver. Defaults to 1e-3.
        atol : float, optional
            The absolute tolerance for the solver. Defaults to 1e-6.
        max_step : float, optional
            The maximum time step to use in the solver. Defaults to np.inf.

        Notes
        -----
        This method uses `scipy.integrate.solve_ivp` to solve the system of residuals in time.
        The system's state is updated using the computed solution at the end of the time step.

        The `get_residuals_from_list` function is used to obtain the system's residuals, and
        `initialize_from_list` updates the domain's state after solving.

        Returns
        -------
        None
            The system's state is updated in-place.
        """

        def f(_, y): return self.get_residuals_from_list(y, split, split_loc)

        # Get the initial state from the domain
        y0 = self._d.listify_interior(split, split_loc)

        # Compute Jacobian if required
        jac = None
        if method in JAC_REQUIRED:
            jac = self.jacobian(y0, split, split_loc)

        # Use solve_ivp to evolve the system
        # Implement basic Euler as part of same wrapper
        sol = Solution()
        if method == "Euler":
            t_current = 0.0
            sol.y = y0
            while t_current &lt; t_diff:
                delta_t = min(t_diff - t_current, max_step)
                sol.y += delta_t * f(t_current, sol.y)
                t_current += delta_t
        else:
            sol = solve_ivp(f, (0, t_diff), y0, method=method,
                            t_eval=[t_diff], jac=jac, max_step=max_step)

        # Update the values of the domain
        self.initialize_from_list(sol.y, split, split_loc)

    def steady_state(
        self, split=False, split_loc=None, sparse=True, dt0=0.0, dtmax=1.0, armijo=False, bounds=None
    ):
        """
        Solve for the steady state of the system.

        Parameters
        ----------
        split : bool, optional
            Whether to split the solution into outer and inner blocks. Defaults to False.
        split_loc : int, optional
            The location to split the solution at. Required if `split` is True.
        sparse : bool, optional
            Whether to use a sparse Jacobian. Defaults to True.
        dt0 : float, optional
            The initial time step to use in pseudo-time. Defaults to 0.0.
        dtmax : float, optional
            The maximum time step to use  in pseudo-time. Defaults to 1.0.
        armijo : bool, optional
            Whether to use the Armijo rule for line searches. Defaults to False.

        Returns
        -------
        iter : int
            The number of iterations performed.
        """

        def _f(u): return self.get_residuals_from_list(u, split, split_loc)
        def _jac(u): return self.jacobian(u, split, split_loc)

        x0 = self._d.listify_interior(split, split_loc)
        num_points, nv = self.get_shape_from_list(x0)

        # Extend bounds based on input
        ext_bounds = self.extend_bounds(
            bounds, num_points, nv, split, split_loc)

        if not split:
            xf, _, iter = newton(
                _f, _jac, x0, sparse=sparse, dt0=dt0, dtmax=dtmax, armijo=armijo,
                bounds=ext_bounds)
        else:
            # Split location will be checked in initialize_from_list
            loc = num_points * split_loc
            xf, _, iter = split_newton(
                _f, _jac, x0, loc, sparse=sparse, dt0=dt0, dtmax=dtmax, armijo=armijo, bounds=ext_bounds
            )

        self.initialize_from_list(xf, split, split_loc)
        return iter</code></pre>
              </details>



  <div class="doc doc-children">









<div class="doc doc-object doc-function">


<h3 id="splitfxm.simulation.Simulation.__init__" class="doc doc-heading">
            <code class="highlight language-python">__init__(d, m, ics, bcs, scheme, scheme_opts={}, ss={})</code>

</h3>


    <div class="doc doc-contents ">

        <p>Initialize a Simulation object.</p>

            <details class="quote">
              <summary>Source code in <code>splitfxm/simulation.py</code></summary>
              <pre class="highlight"><code class="language-python">def __init__(self, d: Domain, m: Model, ics: dict, bcs: dict, scheme, scheme_opts: dict = {}, ss: dict = {}):
    """
    Initialize a Simulation object.
    """
    self._d = d
    self._s = System(m, scheme, scheme_opts)
    self._r = Refiner()
    self._bcs = bcs

    # Steady-state solver settings
    self._ss = ss

    # Set initial conditions
    for c, ictype in ics.items():
        set_initial_condition(self._d, c, ictype)

    # Fill BCs
    for c, bctype in self._bcs.items():
        apply_BC(self._d, c, bctype)

    # Check if stencil size matches
    boundary_cells = self._d.boundaries()[0] + self._d.boundaries()[1]
    if stencil_sizes.get(self._s._scheme) != len(boundary_cells) + 1:
        raise SFXM("Stencil size does not match boundary conditions")</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="splitfxm.simulation.Simulation.get_shape_from_list" class="doc doc-heading">
            <code class="highlight language-python">get_shape_from_list(l)</code>

</h3>


    <div class="doc doc-contents ">

        <p>Get the shape of the list when reshaped into a NumPy array.</p>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>l</code></b>
                  (<code>list</code>)
              –
              <div class="doc-md-description">
                <p>The list to get the shape for.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Returns:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
<b><code>num_points</code></b>(                  <code>int</code>
)              –
              <div class="doc-md-description">
                <p>The number of points in the reshaped array.</p>
              </div>
            </li>
            <li>
<b><code>nv</code></b>(                  <code>int</code>
)              –
              <div class="doc-md-description">
                <p>The number of components per point in the reshaped array.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
            <details class="quote">
              <summary>Source code in <code>splitfxm/simulation.py</code></summary>
              <pre class="highlight"><code class="language-python">def get_shape_from_list(self, l):
    """
    Get the shape of the list when reshaped into a NumPy array.

    Parameters
    ----------
    l : list
        The list to get the shape for.

    Returns
    -------
    num_points : int
        The number of points in the reshaped array.
    nv : int
        The number of components per point in the reshaped array.
    """

    nv = self._d.num_components()

    if len(l) % nv != 0:
        raise SFXM("List length not aligned with interior size")

    num_points = len(l) // nv

    return num_points, nv</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="splitfxm.simulation.Simulation.initialize_from_list" class="doc doc-heading">
            <code class="highlight language-python">initialize_from_list(l, split=False, split_loc=None)</code>

</h3>


    <div class="doc doc-contents ">

        <p>Initialize the domain from a list of values.</p>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>l</code></b>
                  (<code>list</code>)
              –
              <div class="doc-md-description">
                <p>The list of values to initialize the domain with.</p>
              </div>
            </li>
            <li>
              <b><code>split</code></b>
                  (<code>bool</code>, default:
                      <code>False</code>
)
              –
              <div class="doc-md-description">
                <p>Whether to split the values into outer and inner blocks. Defaults to False.</p>
              </div>
            </li>
            <li>
              <b><code>split_loc</code></b>
                  (<code>int</code>, default:
                      <code>None</code>
)
              –
              <div class="doc-md-description">
                <p>The location to split the values at. Required if <code>split</code> is True.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
            <details class="quote">
              <summary>Source code in <code>splitfxm/simulation.py</code></summary>
              <pre class="highlight"><code class="language-python">def initialize_from_list(self, l, split=False, split_loc=None):
    """
    Initialize the domain from a list of values.

    Parameters
    ----------
    l : list
        The list of values to initialize the domain with.
    split : bool, optional
        Whether to split the values into outer and inner blocks. Defaults to False.
    split_loc : int, optional
        The location to split the values at. Required if `split` is True.
    """

    # Just demarcate every nv entries as a row in the 2D array
    num_points, nv = self.get_shape_from_list(l)

    if split:

        if split_loc is None:
            raise SFXM("Split location must be specified in this case")

        if split_loc &gt; nv or split_loc &lt; 0:
            raise SFXM("Split location must be between 0 and nv-1")

        # Same as SplitNewton convention
        # Outer system will be excluding `loc`
        outer_block = array_list_reshape(
            l[: split_loc * num_points], (num_points, split_loc))
        inner_block = array_list_reshape(
            l[split_loc * num_points:], (num_points, nv - split_loc))

        # Concatenate outer and inner blocks
        block = np.hstack((outer_block, inner_block))
    else:
        # No need to split, just use the values_array directly
        block = array_list_reshape(l, (num_points, nv))

    # Assign values to cells in domain
    cells = self._d.interior()
    for i, b in enumerate(cells):
        b.set_values(block[i, :])</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="splitfxm.simulation.Simulation.get_residuals_from_list" class="doc doc-heading">
            <code class="highlight language-python">get_residuals_from_list(l, split=False, split_loc=None)</code>

</h3>


    <div class="doc doc-contents ">

        <p>Get the residuals for the domain given a list of values.</p>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>l</code></b>
                  (<code>list</code>)
              –
              <div class="doc-md-description">
                <p>The list of values to get the residuals for.</p>
              </div>
            </li>
            <li>
              <b><code>split</code></b>
                  (<code>bool</code>, default:
                      <code>False</code>
)
              –
              <div class="doc-md-description">
                <p>Whether to split the residuals into outer and inner blocks. Defaults to False.</p>
              </div>
            </li>
            <li>
              <b><code>split_loc</code></b>
                  (<code>int</code>, default:
                      <code>None</code>
)
              –
              <div class="doc-md-description">
                <p>The location to split the residuals at. Required if <code>split</code> is True.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Returns:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
<b><code>residual_list</code></b>(                  <code>list</code>
)              –
              <div class="doc-md-description">
                <p>The list of residual values.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
            <details class="quote">
              <summary>Source code in <code>splitfxm/simulation.py</code></summary>
              <pre class="highlight"><code class="language-python">def get_residuals_from_list(self, l, split=False, split_loc=None):
    """
    Get the residuals for the domain given a list of values.

    Parameters
    ----------
    l : list
        The list of values to get the residuals for.
    split : bool, optional
        Whether to split the residuals into outer and inner blocks. Defaults to False.
    split_loc : int, optional
        The location to split the residuals at. Required if `split` is True.

    Returns
    -------
    residual_list : list
        The list of residual values.
    """

    # Assign values from list
    # Note domain already exists and we preserve distances
    self.initialize_from_list(l, split, split_loc)

    # Fill BCs
    for c, bctype in self._bcs.items():
        apply_BC(self._d, c, bctype)

    interior_residual_block = self._s.residuals(self._d)

    if split:
        # Split the array into outer and inner blocks
        outer_block = interior_residual_block[:, :split_loc].flatten()
        inner_block = interior_residual_block[:, split_loc:].flatten()
        # Concatenate the flattened outer and inner blocks
        residual_list = np.concatenate((outer_block, inner_block))
    else:
        # Flatten the entire residual block
        residual_list = interior_residual_block.flatten()

    return residual_list</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="splitfxm.simulation.Simulation.extend_bounds" class="doc doc-heading">
            <code class="highlight language-python">extend_bounds(bounds, num_points, nv, split=False, split_loc=None)</code>

</h3>


    <div class="doc doc-contents ">

        <p>Extends the provided input bounds based on whether there is a split or not.</p>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>bounds</code></b>
                  (<code>list of list</code>)
              –
              <div class="doc-md-description">
                <p>A list containing two lists, each of size <code>nv</code>, representing the lower and upper bounds.</p>
              </div>
            </li>
            <li>
              <b><code>num_points</code></b>
                  (<code>int</code>)
              –
              <div class="doc-md-description">
                <p>The number of points to extend each bound to.</p>
              </div>
            </li>
            <li>
              <b><code>nv</code></b>
                  (<code>int</code>)
              –
              <div class="doc-md-description">
                <p>The number of variables, indicating the length of each bound list.</p>
              </div>
            </li>
            <li>
              <b><code>split</code></b>
                  (<code>bool</code>, default:
                      <code>False</code>
)
              –
              <div class="doc-md-description">
                <p>A flag indicating whether to split the bounds at a specific location. Default is <code>False</code>.</p>
              </div>
            </li>
            <li>
              <b><code>split_loc</code></b>
                  (<code>int</code>, default:
                      <code>None</code>
)
              –
              <div class="doc-md-description">
                <p>The index at which to split the bounds if <code>split</code> is <code>True</code>. Default is <code>None</code>.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Returns:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
                  <code>list of list</code>
              –
              <div class="doc-md-description">
                <p>A list containing the extended lower and upper bounds.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
            <details class="quote">
              <summary>Source code in <code>splitfxm/simulation.py</code></summary>
              <pre class="highlight"><code class="language-python">def extend_bounds(self, bounds, num_points, nv, split=False, split_loc=None):
    """
    Extends the provided input bounds based on whether there is a split or not.

    Parameters
    ----------
    bounds : list of list
        A list containing two lists, each of size `nv`, representing the lower and upper bounds.
    num_points : int
        The number of points to extend each bound to.
    nv : int
        The number of variables, indicating the length of each bound list.
    split : bool, optional
        A flag indicating whether to split the bounds at a specific location. Default is `False`.
    split_loc : int, optional
        The index at which to split the bounds if `split` is `True`. Default is `None`.

    Returns
    -------
    list of list
        A list containing the extended lower and upper bounds.
    """
    # Check if bounds is a 2-list, each of size nv
    if bounds is None:
        return None

    if len(bounds) != 2:
        raise SFXM("Bounds must be a list of 2 lists")
    else:
        if len(bounds[0]) != nv or len(bounds[1]) != nv:
            raise SFXM(
                "Each list in bounds must be of length - number of variables")

    if not split:
        return [bounds[0] * num_points, bounds[1] * num_points]
    else:
        if split_loc is None:
            raise SFXM("split_loc must be provided if split is True")
        return [bounds[0][:split_loc] * num_points + bounds[0][split_loc:] * num_points,
                bounds[1][:split_loc] * num_points + bounds[1][split_loc:] * num_points]</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="splitfxm.simulation.Simulation.jacobian" class="doc doc-heading">
            <code class="highlight language-python">jacobian(l, split=False, split_loc=None, epsilon=1e-08)</code>

</h3>


    <div class="doc doc-contents ">

        <p>Calculate the Jacobian of the system using finite differences.</p>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>l</code></b>
                  (<code>list</code>)
              –
              <div class="doc-md-description">
                <p>The list of values to calculate the Jacobian for.</p>
              </div>
            </li>
            <li>
              <b><code>split</code></b>
                  (<code>bool</code>, default:
                      <code>False</code>
)
              –
              <div class="doc-md-description">
                <p>Whether to split the Jacobian into outer and inner blocks. Defaults to False.</p>
              </div>
            </li>
            <li>
              <b><code>split_loc</code></b>
                  (<code>int</code>, default:
                      <code>None</code>
)
              –
              <div class="doc-md-description">
                <p>The location to split the Jacobian at. Required if <code>split</code> is True.</p>
              </div>
            </li>
            <li>
              <b><code>epsilon</code></b>
                  (<code>float</code>, default:
                      <code>1e-08</code>
)
              –
              <div class="doc-md-description">
                <p>The finite difference step size. Defaults to 1e-8.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Returns:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
<b><code>jac</code></b>(                  <code><span title="scipy.sparse.lil_matrix">lil_matrix</span></code>
)              –
              <div class="doc-md-description">
                <p>The Jacobian of the system.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
            <details class="quote">
              <summary>Source code in <code>splitfxm/simulation.py</code></summary>
              <pre class="highlight"><code class="language-python">def jacobian(self, l, split=False, split_loc=None, epsilon=1e-8):
    """
    Calculate the Jacobian of the system using finite differences.

    Parameters
    ----------
    l : list
        The list of values to calculate the Jacobian for.
    split : bool, optional
        Whether to split the Jacobian into outer and inner blocks. Defaults to False.
    split_loc : int, optional
        The location to split the Jacobian at. Required if `split` is True.
    epsilon : float, optional
        The finite difference step size. Defaults to 1e-8.

    Returns
    -------
    jac : scipy.sparse.lil_matrix
        The Jacobian of the system.
    """
    # Initialize domain from the provided list and apply boundary conditions
    self.initialize_from_list(l, split, split_loc)
    for c, bctype in self._bcs.items():
        apply_BC(self._d, c, bctype)

    # Find the variables with periodic BCs and their directions
    periodic_bcs_dict = get_periodic_bcs(self._bcs, self._d)

    # Get the number of points and variables
    num_points, nv = self.get_shape_from_list(l)
    n = num_points * nv

    # Create a sparse matrix for the Jacobian
    jac = lil_matrix((n, n))

    # Retrieve cells and boundary parameters
    cells = self._d.cells()
    nb_left, nb_right, ilo, ihi = self._d.nb(btype.LEFT), self._d.nb(
        btype.RIGHT), self._d.ilo(), self._d.ihi()

    # Use same point iteration as system residuals
    # Iterating over interior points
    for i in range(ilo, ihi + 1):
        # Define the neighborhood and band around the current cell
        cell_sub = [cells[i + offset]
                    for offset in range(-nb_left, nb_right + 1)]
        # Indices of points that affect the Jacobian (or part of the band)
        band = list(range(max(ilo, i - nb_left),
                    min(ihi + 1, i + nb_right + 1)))

        # Calculate unperturbed residuals
        rhs = self._s._model.equation().residuals(cell_sub, self._s._scheme)

        # Perturb each variable and compute the Jacobian columns
        for j in range(nv):
            # Extend the band if required for that variable
            # Only required for periodic BC for now
            if j in periodic_bcs_dict.keys():
                dirs = periodic_bcs_dict[j]
                band = extend_band(band, dirs, i, self._d)

            for loc in band:
                # Compared to center_cell, what is the index of the cell
                # to be perturbed
                cell = cells[loc]
                current_value = cell.value(j)

                # Perturb the current variable and compute perturbed residuals
                cell.set_value(j, current_value + epsilon)

                # Apply BC again if cell is adjacent to boundary
                if ilo in band or ihi in band:
                    for c, bctype in self._bcs.items():
                        apply_BC(self._d, c, bctype)

                # Calculate updated residual
                rhs_pert = self._s._model.equation().residuals(cell_sub, self._s._scheme)

                # Reset the value
                cell.set_value(j, current_value)
                # Apply BC again if cell is adjacent to boundary
                if ilo in band or ihi in band:
                    for c, bctype in self._bcs.items():
                        apply_BC(self._d, c, bctype)

                # Compute the difference and assign to the Jacobian
                col = (rhs_pert - rhs) / epsilon

                # Assign the calculated column to the Jacobian
                # Blocks of nv*nv matrices are computed
                # row_idx gives the start of the column vector
                # First point starts at 0, second point starts at nv and so on
                # For col_idx, loc - ilo gives shift from 0 for the block in multiples of nv
                if not split:
                    row_idx = (i - ilo) * nv
                    col_idx = (loc - ilo) * nv + j
                    jac[row_idx:row_idx + nv, col_idx] = col
                else:
                    # Split location will be checked in initialize_from_list
                    # Sizes of the sub-Jacobians
                    na, nc = split_loc, (nv - split_loc)
                    # Jumps of block_offset instead of nv here
                    block_offset = num_points * na

                    # First part of residuals
                    # Same as previous but use na instead
                    row_idx = (i - ilo) * na
                    # col_idx jumps to right part of Jacobian
                    # depending on the variable if pre- or post-split
                    if j &lt; na:
                        col_idx = (loc - ilo) * na + j
                    else:
                        # Jumps of nc in post-split parts
                        # j-na to ensure post-split variables start afresh
                        col_idx = block_offset + \
                            (loc - ilo) * nc + (j - na)

                    jac[row_idx:row_idx + na, col_idx] = col[:na]

                    # Second part of residuals
                    # col_idx remains same as previous
                    row_idx = block_offset + (i - ilo) * nc
                    jac[row_idx:row_idx + nc, col_idx] = col[na:]

    return jac</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="splitfxm.simulation.Simulation.evolve" class="doc doc-heading">
            <code class="highlight language-python">evolve(t_diff, split=False, split_loc=None, method='RK45', rtol=0.001, atol=1e-06, max_step=np.inf)</code>

</h3>


    <div class="doc doc-contents ">

        <p>Evolve the system in time using an ODE solver for a given time step.</p>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>t_diff</code></b>
                  (<code>float</code>)
              –
              <div class="doc-md-description">
                <p>The time advancement to be made.</p>
              </div>
            </li>
            <li>
              <b><code>split</code></b>
                  (<code>bool</code>, default:
                      <code>False</code>
)
              –
              <div class="doc-md-description">
                <p>If True, applies a domain splitting technique. Defaults to False.</p>
              </div>
            </li>
            <li>
              <b><code>split_loc</code></b>
                  (<code>optional</code>, default:
                      <code>None</code>
)
              –
              <div class="doc-md-description">
                <p>Specifies the location or configuration for domain splitting. Default is None.</p>
              </div>
            </li>
            <li>
              <b><code>method</code></b>
                  (<code>str</code>, default:
                      <code>&#39;RK45&#39;</code>
)
              –
              <div class="doc-md-description">
                <p>The integration method to use for solving the system. Defaults to 'RK45'.
Possible options include 'RK45', 'RK23', 'DOP853', etc. 
Refer to the scipy documentation for a full list of supported methods.</p>
              </div>
            </li>
            <li>
              <b><code>rtol</code></b>
                  (<code>float</code>, default:
                      <code>0.001</code>
)
              –
              <div class="doc-md-description">
                <p>The relative tolerance for the solver. Defaults to 1e-3.</p>
              </div>
            </li>
            <li>
              <b><code>atol</code></b>
                  (<code>float</code>, default:
                      <code>1e-06</code>
)
              –
              <div class="doc-md-description">
                <p>The absolute tolerance for the solver. Defaults to 1e-6.</p>
              </div>
            </li>
            <li>
              <b><code>max_step</code></b>
                  (<code>float</code>, default:
                      <code><span title="numpy.inf">inf</span></code>
)
              –
              <div class="doc-md-description">
                <p>The maximum time step to use in the solver. Defaults to np.inf.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

<details class="note" open>
  <summary>Notes</summary>
  <p>This method uses <code>scipy.integrate.solve_ivp</code> to solve the system of residuals in time.
The system's state is updated using the computed solution at the end of the time step.</p>
<p>The <code>get_residuals_from_list</code> function is used to obtain the system's residuals, and
<code>initialize_from_list</code> updates the domain's state after solving.</p>
</details>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Returns:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
                  <code>None</code>
              –
              <div class="doc-md-description">
                <p>The system's state is updated in-place.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
            <details class="quote">
              <summary>Source code in <code>splitfxm/simulation.py</code></summary>
              <pre class="highlight"><code class="language-python">def evolve(self, t_diff: float, split=False, split_loc=None, method='RK45', rtol=1e-3, atol=1e-6, max_step=np.inf):
    """
    Evolve the system in time using an ODE solver for a given time step.

    Parameters
    ----------
    t_diff : float
        The time advancement to be made.
    split : bool, optional
        If True, applies a domain splitting technique. Defaults to False.
    split_loc : optional
        Specifies the location or configuration for domain splitting. Default is None.
    method : str, optional
        The integration method to use for solving the system. Defaults to 'RK45'.
        Possible options include 'RK45', 'RK23', 'DOP853', etc. 
        Refer to the scipy documentation for a full list of supported methods.
    rtol : float, optional
        The relative tolerance for the solver. Defaults to 1e-3.
    atol : float, optional
        The absolute tolerance for the solver. Defaults to 1e-6.
    max_step : float, optional
        The maximum time step to use in the solver. Defaults to np.inf.

    Notes
    -----
    This method uses `scipy.integrate.solve_ivp` to solve the system of residuals in time.
    The system's state is updated using the computed solution at the end of the time step.

    The `get_residuals_from_list` function is used to obtain the system's residuals, and
    `initialize_from_list` updates the domain's state after solving.

    Returns
    -------
    None
        The system's state is updated in-place.
    """

    def f(_, y): return self.get_residuals_from_list(y, split, split_loc)

    # Get the initial state from the domain
    y0 = self._d.listify_interior(split, split_loc)

    # Compute Jacobian if required
    jac = None
    if method in JAC_REQUIRED:
        jac = self.jacobian(y0, split, split_loc)

    # Use solve_ivp to evolve the system
    # Implement basic Euler as part of same wrapper
    sol = Solution()
    if method == "Euler":
        t_current = 0.0
        sol.y = y0
        while t_current &lt; t_diff:
            delta_t = min(t_diff - t_current, max_step)
            sol.y += delta_t * f(t_current, sol.y)
            t_current += delta_t
    else:
        sol = solve_ivp(f, (0, t_diff), y0, method=method,
                        t_eval=[t_diff], jac=jac, max_step=max_step)

    # Update the values of the domain
    self.initialize_from_list(sol.y, split, split_loc)</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="splitfxm.simulation.Simulation.steady_state" class="doc doc-heading">
            <code class="highlight language-python">steady_state(split=False, split_loc=None, sparse=True, dt0=0.0, dtmax=1.0, armijo=False, bounds=None)</code>

</h3>


    <div class="doc doc-contents ">

        <p>Solve for the steady state of the system.</p>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>split</code></b>
                  (<code>bool</code>, default:
                      <code>False</code>
)
              –
              <div class="doc-md-description">
                <p>Whether to split the solution into outer and inner blocks. Defaults to False.</p>
              </div>
            </li>
            <li>
              <b><code>split_loc</code></b>
                  (<code>int</code>, default:
                      <code>None</code>
)
              –
              <div class="doc-md-description">
                <p>The location to split the solution at. Required if <code>split</code> is True.</p>
              </div>
            </li>
            <li>
              <b><code>sparse</code></b>
                  (<code>bool</code>, default:
                      <code>True</code>
)
              –
              <div class="doc-md-description">
                <p>Whether to use a sparse Jacobian. Defaults to True.</p>
              </div>
            </li>
            <li>
              <b><code>dt0</code></b>
                  (<code>float</code>, default:
                      <code>0.0</code>
)
              –
              <div class="doc-md-description">
                <p>The initial time step to use in pseudo-time. Defaults to 0.0.</p>
              </div>
            </li>
            <li>
              <b><code>dtmax</code></b>
                  (<code>float</code>, default:
                      <code>1.0</code>
)
              –
              <div class="doc-md-description">
                <p>The maximum time step to use  in pseudo-time. Defaults to 1.0.</p>
              </div>
            </li>
            <li>
              <b><code>armijo</code></b>
                  (<code>bool</code>, default:
                      <code>False</code>
)
              –
              <div class="doc-md-description">
                <p>Whether to use the Armijo rule for line searches. Defaults to False.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Returns:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
<b><code>iter</code></b>(                  <code>int</code>
)              –
              <div class="doc-md-description">
                <p>The number of iterations performed.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
            <details class="quote">
              <summary>Source code in <code>splitfxm/simulation.py</code></summary>
              <pre class="highlight"><code class="language-python">def steady_state(
    self, split=False, split_loc=None, sparse=True, dt0=0.0, dtmax=1.0, armijo=False, bounds=None
):
    """
    Solve for the steady state of the system.

    Parameters
    ----------
    split : bool, optional
        Whether to split the solution into outer and inner blocks. Defaults to False.
    split_loc : int, optional
        The location to split the solution at. Required if `split` is True.
    sparse : bool, optional
        Whether to use a sparse Jacobian. Defaults to True.
    dt0 : float, optional
        The initial time step to use in pseudo-time. Defaults to 0.0.
    dtmax : float, optional
        The maximum time step to use  in pseudo-time. Defaults to 1.0.
    armijo : bool, optional
        Whether to use the Armijo rule for line searches. Defaults to False.

    Returns
    -------
    iter : int
        The number of iterations performed.
    """

    def _f(u): return self.get_residuals_from_list(u, split, split_loc)
    def _jac(u): return self.jacobian(u, split, split_loc)

    x0 = self._d.listify_interior(split, split_loc)
    num_points, nv = self.get_shape_from_list(x0)

    # Extend bounds based on input
    ext_bounds = self.extend_bounds(
        bounds, num_points, nv, split, split_loc)

    if not split:
        xf, _, iter = newton(
            _f, _jac, x0, sparse=sparse, dt0=dt0, dtmax=dtmax, armijo=armijo,
            bounds=ext_bounds)
    else:
        # Split location will be checked in initialize_from_list
        loc = num_points * split_loc
        xf, _, iter = split_newton(
            _f, _jac, x0, loc, sparse=sparse, dt0=dt0, dtmax=dtmax, armijo=armijo, bounds=ext_bounds
        )

    self.initialize_from_list(xf, split, split_loc)
    return iter</code></pre>
            </details>
    </div>

</div>



  </div>

    </div>

</div>


<div class="doc doc-object doc-function">


<h2 id="splitfxm.simulation.array_list_reshape" class="doc doc-heading">
            <code class="highlight language-python">array_list_reshape(l, shape)</code>

</h2>


    <div class="doc doc-contents ">

        <p>Reshape a list into a list of 1D NumPy arrays.</p>


<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Parameters:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
              <b><code>l</code></b>
                  (<code>list</code>)
              –
              <div class="doc-md-description">
                <p>The list to reshape.</p>
              </div>
            </li>
            <li>
              <b><code>shape</code></b>
                  (<code>tuple</code>)
              –
              <div class="doc-md-description">
                <p>The shape to reshape the list into.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

<table class="field-list">
  <colgroup>
    <col class="field-name" />
    <col class="field-body" />
  </colgroup>
  <tbody valign="top">
    <tr class="field">
      <th class="field-name">Returns:</th>
      <td class="field-body">
        <ul class="first simple">
            <li>
<b><code>reshaped_list</code></b>(                  <code>list of ndarray</code>
)              –
              <div class="doc-md-description">
                <p>The reshaped list.</p>
              </div>
            </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
            <details class="quote">
              <summary>Source code in <code>splitfxm/simulation.py</code></summary>
              <pre class="highlight"><code class="language-python">def array_list_reshape(l, shape):
    """
    Reshape a list into a list of 1D NumPy arrays.

    Parameters
    ----------
    l : list
        The list to reshape.
    shape : tuple
        The shape to reshape the list into.

    Returns
    -------
    reshaped_list : list of ndarray
        The reshaped list.
    """
    return np.array(l).reshape(shape)</code></pre>
            </details>
    </div>

</div>



  </div>

    </div>

</div>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../system/" class="btn btn-neutral float-left" title="System"><span class="icon icon-circle-arrow-left"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href="../system/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
  </span>
</div>
    <script src="../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "..";</script>
    <script src="../js/theme_extra.js"></script>
    <script src="../js/theme.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
